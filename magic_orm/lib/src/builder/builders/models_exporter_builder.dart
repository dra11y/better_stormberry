import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:glob/glob.dart';
import 'package:source_gen/source_gen.dart';

import '../global_options.dart';
import '../utils.dart';

/// BUILD STEP 1: Generate `List<Type> models` export for all models in shared
/// project as `models.export.dart` for import into server/client projects.
class ModelsExporterBuilder extends Builder {
  ModelsExporterBuilder(BuilderOptions options)
      : options = GlobalOptions.parse(options.config);

  static const magicExt = r'$lib$';

  final GlobalOptions options;

  late final outputFile = 'lib/${buildExtensions[magicExt]!.first}';

  static const generatedComments = [
    'GENERATED CODE - DO NOT MODIFY BY HAND',
    '',
    'Generated by: magic_orm',
  ];

  @override
  Future<void> build(BuildStep buildStep) async {
    print('GlobalOptions: $options');
    final schema = await buildStep.fetchResource<ModelState>(modelResource);

    // Loop through all libraries in the project and collect models.
    await for (final input in buildStep.findAssets(Glob('**/*.dart'))) {
      final library = await buildStep.resolver.libraryFor(input);
      try {
        await collectModels(schema, library, buildStep);
      } catch (e, st) {
        print('\x1B[31mFailed to collect models from $library:\n\n$e\x1B[0m\n');
        print(st);
      }
    }

    // Skip this step if no models in the current project.
    if (schema.models.isEmpty) {
      return;
    }

    final emitter = DartEmitter.scoped(
      orderDirectives: true,
      useNullSafetySyntax: true,
    );

    // Generate a single library file with list of all model types.
    final generated = Library(
      (b) => b
        ..comments.addAll([
          ...generatedComments,
          '',
          'Define your database with the [@MagicDatabase] annotation using',
          'these models as follows:',
          '',
          '```',
          'import \'package:${buildStep.inputId.package}/models.export.dart\';',
          '',
          '@MagicDatabase(models: models)',
          'class Database extends PgDatabase { ... }',
          '```',
        ])
        ..body.add(
          declareConst('models', type: referType(List<Type>))
              .assign(
                literalList(schema.refs),
              )
              .statement,
        ),
    ).accept(emitter).toString();

    final modelExports =
        DartFormatter(pageWidth: options.lineLength).format(generated);

    final assetId = AssetId(buildStep.inputId.package, outputFile);
    buildStep.writeAsString(assetId, modelExports);
  }

  Future<void> collectModels(
      ModelState state, LibraryElement library, BuildStep buildStep) async {
    final reader = LibraryReader(library);
    final models = reader.annotatedWith(modelChecker);
    state.models.addAll({
      for (final model in models)
        model.element.librarySource!.uri: model.element as InterfaceElement,
    });
  }

  @override
  Map<String, List<String>> get buildExtensions => {
        magicExt: ['models.export.dart']
      };
}

final modelResource = Resource<ModelState>(() => ModelState());

class ModelState {
  final Map<Uri, InterfaceElement> models = {};

  // Get a list of model type refs with relative Uris.
  Iterable<Reference> get refs =>
      models.entries.map((m) => refer(m.value.name, m.key.relative));
}
